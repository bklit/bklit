# Bklit - Claude Code Configuration

This project uses **Ultracite** for linting and formatting with Biome.

## Code Quality & Formatting

- **Linter**: Biome via Ultracite (opinionated preset)
- **Formatter**: Biome (runs automatically on save)
- **Type Checker**: TypeScript strict mode with `strictNullChecks`

## Commands

```bash
# Check code for issues (no fixes)
pnpm format-and-lint

# Auto-fix issues
pnpm format-and-lint:fix

# Or use Ultracite directly
pnpm ultracite check
pnpm ultracite fix
```

## Best Practices

1. **Type Safety**: This project enforces strict TypeScript. Avoid using `any`, handle `null/undefined` explicitly.
2. **Accessibility**: ARIA attributes and semantic HTML are enforced by default.
3. **Auto-formatting**: Code is automatically formatted on save. Don't fight the formatter!
4. **React/Next.js**: Follow React hooks rules and Next.js best practices (enforced by linter).
5. **Tailwind CSS**: Use Tailwind v4.1+ syntax (e.g., `size-4` instead of `w-4 h-4`).

## Monorepo Structure

This is a pnpm workspace monorepo:
- `apps/dashboard` - Main analytics dashboard (Next.js)
- `apps/website` - Marketing website (Next.js)
- `apps/docs` - Documentation site (Next.js)
- `apps/playground` - Example e-commerce app (React + Vite)
- `packages/*` - Shared packages (auth, db, analytics, UI, etc.)

## Tech Stack

- **Framework**: Next.js 15 (App Router), React 19
- **Database**: PostgreSQL (via Prisma)
- **Analytics**: Self-hosted ClickHouse on Hetzner
- **Styling**: Tailwind CSS v4.1
- **UI Components**: shadcn/ui (Radix primitives)
- **Type Safety**: TypeScript, tRPC, Zod
- **Payments**: Polar.sh
- **Auth**: Better Auth

## Development

```bash
# Start local dev environment
pnpm dev

# Run type checking across all packages
pnpm typecheck

# Database operations
pnpm db:studio
pnpm db:migrate
pnpm db:generate
```

## AI Agent Guidelines

When working on this codebase:
1. Always check for existing shadcn/ui components before creating new ones
2. Use tRPC for data fetching (check `packages/api/src/router/*`)
3. Follow the established patterns in `hooks/` and `lib/` directories
4. Keep server components server-side, create separate client components when needed
5. Organize utility functions into appropriate `lib/` subdirectories
6. Minimize comments - code should be self-documenting
7. Import components using named imports: `import { Component } from ...`

